% write_regen_section(client_name+'.cpp[Header]', header: true) do
/**
 * @file    <%= client_name %>.cpp
 * @author  Unknown
 * @brief   Client main
 *
 * Generated by 'brix11 generate client' @ <%= Time.now %>
 */
% end

% idl_names.each do |i|
#include "<%= i %>C.h"
% end
#include "ace/Get_Opt.h"
#include "tao/x11/log.h"
% write_regen_section(client_name+'.cpp[User Includes]', default_content: '// Your includes/code here')

std::string ior = "file://server.ior";

% write_regen_section(client_name+'.cpp[Argument Parsing]') do
bool
parse_args (int argc, char *argv[])
{
  ACE_Get_Opt get_opts (argc, argv, ACE_TEXT("k:"));
  int c;

  while ((c = get_opts ()) != -1)
    switch (c)
      {
      case 'k':
        ior = get_opts.opt_arg ();
        break;

      case '?':
      default:
        taox11_error << "usage: -k <ior>"
              << std::endl;
        return false;
      }
  // Indicates successful parsing of the command line
  return true;
}
% end

int
main(int argc, char* argv[])
{
  try
    {
% write_regen_section(client_name+'.cpp[User Startup]', indent: 3) do
      // Your startup code here

      // Make some logging visible.
      X11_LOGGER::priority_mask (x11_logger::LP_INFO|x11_logger::LP_WARNING|x11_logger::LP_ALL_ERROR);
      X11_LOGGER::verbosity_mask (x11_logger::V_PRIO|x11_logger::V_CATEGORY|x11_logger::V_TIME);
% end
      IDL::traits<CORBA::ORB>::ref_type _orb = CORBA::ORB_init (argc, argv);

      if (!_orb)
        {
          taox11_error
            << "ERROR: CORBA::ORB_init (argc, argv) returned null ORB."
            << std::endl;
          return 1;
        }

% write_regen_section(client_name+'.cpp[User Arguments]', indent: 3) do
      // Your argument handling here
      if (!parse_args (argc, argv))
        return 1;

% end
% write_regen_section(client_name+'.cpp[User Client Main]', indent: 3) do
      IDL::traits<CORBA::Object>::ref_type obj = _orb->string_to_object (ior);

      if (!obj)
        {
          taox11_error
            << "ERROR: string_to_object(<ior>) returned null reference."
            << std::endl;
          return 1;
        }

      taox11_info << "retrieved object reference" << std::endl;

      IDL::traits<<%= scoped_interface %>>::ref_type <%= interface_obj %> = IDL::traits<<%= scoped_interface %>>::narrow (obj);

      if (!<%= interface_obj %>)
        {
          taox11_error
            << "ERROR: IDL::traits<<%= scoped_interface %>>::narrow (obj) returned null object."
            << std::endl;
          return 1;
        }

      taox11_info << "narrowed <%= scoped_interface %> interface" << std::endl;

      // Your code here
%   if has_shutdown?

      taox11_info << "shutting down...";

      <%= interface_obj %>->shutdown ();

      taox11_info << std::endl;

%   end
% end

      _orb->destroy ();
    }
  catch (const std::exception& e)
    {
      taox11_error << "exception caught: " << e.what () << std::endl;
      return 1;
    }
  return 0;
}

% write_regen_section(client_name+'.cpp[User Code]', default_content: '// Your code here', footer: true)
