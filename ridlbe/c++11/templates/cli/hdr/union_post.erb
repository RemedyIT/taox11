  // generated from <%= ridl_template_path %>
% if has_implicit_default? || has_default?
  /// Default constructor creating an union initialized to
  /// the default cause
% else
  /// Default constructor creating an empty union
%end
  <%= cxxname %> () = default;
  /// Copy constructor
  <%= cxxname %> (<%= cxx_in_type %>) = default;
  /// Move constructor
  <%= cxxname %> (<%= cxx_move_type %>) = default;
  /// Destructor
  ~<%= cxxname %> () = default;
  /// Copy assignment operator
  <%= cxxtype %> &operator= (<%= cxx_in_type %>) = default;
  /// Move assignment operator
  <%= cxxtype %> &operator= (<%= cxx_move_type %>) = default;

  /// Set the discriminator. Only possible to set it to a
  /// value within the same current union member, otherwise
  /// a BAD_PARAM exception is thrown
  inline void _d (<%= switch_in_cxxtype %>);
  /// Get the discriminator
  [[nodiscard]] inline <%= switch_in_cxxtype %> _d () const  { return this->disc_; }
% members.each do |_m|
%if _m.is_default?
% default_disc = default_label
%else
% default_disc = _m.nondefault_labels.first
%end

  /// @copydoc <%= _m.doc_scoped_name %>
  //@{
  /// Set the value of the union, the discriminator is automatically
  /// set to the correct value
  inline void <%= _m.cxxname %> (<%= _m.cxx_in_type %> _x11_<%= _m.cxxname %><% if _m.has_multiple_discriminators? %>, <%= switch_in_cxxtype %> _x11_disc = <%= default_disc %><% end %>);
%   unless _m.is_pod? || _m.is_reference?
  /// Set the value of the union, the discriminator is automatically
  /// set to the correct value
  inline void <%= _m.cxxname %> (<%= _m.cxx_move_type %> _x11_<%= _m.cxxname %><% if _m.has_multiple_discriminators? %>, <%= switch_in_cxxtype %> _x11_disc = <%= default_disc %><% end %>);
%   end
  /// Get the value of the union, if the discriminator doesn't match a
  /// BAD_PARAM exception is thrown
  [[nodiscard]] inline <%= _m.cxx_in_type %> <%= _m.cxxname %> () const;
  /// Get the value of the union, if the discriminator doesn't match a
  /// BAD_PARAM exception is thrown
  [[nodiscard]] inline <%= _m.cxx_out_type %> <%= _m.cxxname %> ();
  //@}
% end
% if has_implicit_default?

  /// Modifier that sets the union to a legal default value
  inline void _default ();
% end

  /// Exchange the value of two unions in an efficient matter
  inline void swap (<%= cxx_inout_type %> u);

private:
  <%= switch_cxxtype %> disc_ {<% if has_default?() || has_implicit_default?() %><%= default_label %><% else %><%= members.first.nondefault_labels.first %><% end %>};
  using u_type_ = std::variant<<% members.each do |_m| %><%= _m.cxx_member_type %><% unless _m.equal?(members.last) %>, <% end %><% end %>>;
% def_index = 0
% default_value = ''
% members.each_with_index do |_m, _index|
%   if (has_default?() && _m.is_default?) || (!has_default?() && _m == members.first)
%     def_index = _index
%     default_value = ", #{_m.default_value}"
%   end
% end
%# The default member or the first member should use the value_initializer
  u_type_ u_ {std::in_place_index<<%= def_index %>><%= default_value %>};
}; // class <%= cxxname %>

inline void swap (<%= scoped_cxx_out_type %> m1, <%= scoped_cxx_out_type %> m2) { m1.swap (m2); }
